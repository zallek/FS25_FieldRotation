local modName = CRY_FieldHistory and CRY_FieldHistory.MOD_NAME -- for reload
CRY_FieldHistory = {}
CRY_FieldHistory.MOD_NAME = g_currentModName or modName
CRY_FieldHistory.GAMESAVE_PATH = "." .. CRY_FieldHistory.MOD_NAME .. ".history.entry"
CRY_FieldHistory.FULL_GAMESAVE_PATH = "fields.field(?)" .. CRY_FieldHistory.GAMESAVE_PATH .. "(?)"

local fieldHistoryClass = Class(CRY_FieldHistory)

function CRY_FieldHistory.new(o)
    local class = o or fieldHistoryClass
    local instance = setmetatable({}, class)
    instance.historyEntries = {}
    return instance
end

function CRY_FieldHistory:registerXmlSchema()
    local xmlSchemaSavegame = FieldManager.xmlSchemaSavegame

    xmlSchemaSavegame:register(XMLValueType.INT, CRY_FieldHistory.FULL_GAMESAVE_PATH .. "#monotonicDay", "Monotonic day", nil, false)
    xmlSchemaSavegame:register(XMLValueType.FLOAT, CRY_FieldHistory.FULL_GAMESAVE_PATH .. "#dayTime", "Day time", nil, false)
    xmlSchemaSavegame:register(XMLValueType.STRING, CRY_FieldHistory.FULL_GAMESAVE_PATH .. "#fruitType", "Name of the fruit type", nil, false)
    xmlSchemaSavegame:register(XMLValueType.INT, CRY_FieldHistory.FULL_GAMESAVE_PATH .. "#growthState", "Growthstate of the fruit type", nil, false)
    xmlSchemaSavegame:register(XMLValueType.BOOL, CRY_FieldHistory.FULL_GAMESAVE_PATH .. "#generated", "Entry was generated by the mod", nil, false)
end

function CRY_FieldHistory:loadFromXMLFile(xmlFile, key)
    print("CRY_FieldHistory.loadFromXMLFile " .. key)
    for _, entryKey in xmlFile:iterator(key .. CRY_FieldHistory.GAMESAVE_PATH) do
        local monotonicDay = xmlFile:getValue(entryKey .. "#monotonicDay")
        local dayTime = xmlFile:getValue(entryKey .. "#dayTime") * 60000
        local fruitTypeName = xmlFile:getValue(entryKey .. "#fruitType")
        local growthState = xmlFile:getValue(entryKey .. "#growthState")
        local fruitType = g_fruitTypeManager:getFruitTypeByName(fruitTypeName)
        local fruitTypeIndex = fruitType and fruitType.index or 0
        self:appendHistoryEntry(monotonicDay, dayTime, fruitTypeIndex, growthState)
    end
end

function CRY_FieldHistory:saveToXMLFile(xmlFile, key)
    print("CRY_FieldHistory.saveToXMLFile " .. key)
    for entryIndex, entry in ipairs(self.historyEntries) do
        local entryKey = string.format("%s(%d)", key .. CRY_FieldHistory.GAMESAVE_PATH, entryIndex - 1)
        local fruitTypeName = g_fruitTypeManager:getFruitTypeNameByIndex(entry.fruitTypeIndex)
        xmlFile:setValue(entryKey .. "#monotonicDay", entry.monotonicDay)
        xmlFile:setValue(entryKey .. "#dayTime", entry.dayTime / 60000)
        xmlFile:setValue(entryKey .. "#fruitType", fruitTypeName)
        xmlFile:setValue(entryKey .. "#growthState", entry.growthState)
        xmlFile:setValue(entryKey .. "#generated", entry.generated)
    end
end

function CRY_FieldHistory:update(fieldState)
    if fieldState.farmlandId ~= 1 then -- TODO remove this?
        local currentMonotonicDay = g_currentMission.environment.currentMonotonicDay
        local currentDayTime = g_currentMission.environment.dayTime -- TODO: check if it correctly allows to order entries when several days by period
        local fruitTypeIndex = fieldState.fruitTypeIndex
        local growthState = fieldState.growthState
        local lastEntry = self.historyEntries[#self.historyEntries]

        if lastEntry == nil or lastEntry.monotonicDay ~= currentMonotonicDay or lastEntry.fruitTypeIndex ~= fruitTypeIndex or lastEntry.growthState ~= growthState then
            self:appendHistoryEntry(currentMonotonicDay, currentDayTime, fruitTypeIndex, growthState)
        end

        if #self.historyEntries < 24 then
            self:generateHistory(2)
        end
    end
end

function CRY_FieldHistory:buildHistoryEntry(monotonicDay, dayTime, fruitTypeIndex, growthState, generated)
    return {
        monotonicDay = monotonicDay,
        dayTime = dayTime,
        fruitTypeIndex = fruitTypeIndex,
        growthState = growthState,
        generated = generated or nil,
    }
end

function CRY_FieldHistory:appendHistoryEntry(monotonicDay, dayTime, fruitTypeIndex, growthState)
    local entry = self:buildHistoryEntry(monotonicDay, dayTime, fruitTypeIndex, growthState, false)
    table.insert(self.historyEntries, entry)
end

function CRY_FieldHistory:preppendHistoryEntry(monotonicDay, dayTime, fruitTypeIndex, growthState, generated)
    local entry = self:buildHistoryEntry(monotonicDay, dayTime, fruitTypeIndex, growthState, generated)
    table.insert(self.historyEntries, 1, entry)
end

function CRY_FieldHistory:getLastFruitTypes(nbFruitTypes)
end

function CRY_FieldHistory:generateHistory(nbFruitTypes)
    local firstEntry = self.historyEntries[1]
    if not firstEntry then return end

    -- local fruitTypes = g_fruitTypeManager:getFruitTypes()
    -- fruitType = fruitTypes[math.random(1, #fruitTypes)]

    local backwardHistory = self:generateBackwardHistoryEntry(firstEntry)
    for _, entry in ipairs(backwardHistory) do
        self:preppendHistoryEntry(entry.monotonicDay, entry.dayTime, entry.fruitTypeIndex, entry.growthState, true)
    end
end

function CRY_FieldHistory:generateBackwardHistoryEntry(untilEntry)
    -- Generate realistic history based on fruit types seasonal growth data
    -- Useful for testing and for initializing the gameplay for players when the mod is newly installed
    local entries = {}

    local fruitType = g_fruitTypeManager:getFruitTypeByIndex(untilEntry.fruitTypeIndex)
    if fruitType == nil then
        return entries
    end

    local growthData = fruitType.growthDataSeasonal
    local currentDay = untilEntry.monotonicDay
    local currentGrowthState = untilEntry.growthState

    -- Generate entries from the current state backwards
    while currentDay > 1 and currentGrowthState > 1 do
        -- Move backwards in time
        currentDay = currentDay - 1

        -- Get the period data for the current day
        local period = g_currentMission.environment:getPeriodFromDay(currentDay)
        local periodData = growthData.periods[period]

        local isCut = fruitType:getIsCut(currentGrowthState)
        if isCut then
            if periodData.isHarvestable then
                -- Find what growth state could have led to our current state
                -- We need to find the state that would harvest transition TO our current state
                for fromState, toState in pairs(fruitType.harvestReadyTransitions) do
                    if toState == currentGrowthState then
                        currentGrowthState = fromState
                        break
                    end
                end
            else
                -- Not harvestable, so we keep the current state
                currentGrowthState = currentGrowthState
            end
        else
            -- Find what growth state could have led to our current state
            -- We need to find the state that would growth transition TO our current state
            for fromState, toState in pairs(periodData.growthMapping) do
                if toState == currentGrowthState then
                    currentGrowthState = fromState
                    break
                end
            end
        end

        -- Add current state
        table.insert(entries, {
            monotonicDay = currentDay,
            dayTime = 0,
            growthState = currentGrowthState,
            fruitType = fruitType.index,
        })
    end

    return entries
end


--[[ 
monotonicDay | period | growthState
11 | 11 | 10
10 | 10 | 10
9 | 9 | 8  (isHarvestable)
8 | 8 | 7 
7 | 7 | 6
 ]]